# InnoDB记录的存储结构

不同的存储引擎，存储的数据格式都是不一样的。比如 Memory 存储引擎是将数据存储在内存中。而这篇文档描述了我们的数据在 InnoDB 存储引擎中的存储位置、存储格式以及读写方式。

## InnoDB 逻辑存储结构 {id="logic-storage-structure"}

![image](http://file-linker.oss-cn-hangzhou.aliyuncs.com/s4qogQ7cwFFDktIaRpak.jpeg)

## InnoDB 的页 {id="page"}

InnoDB 是将数据存储在磁盘中，即使服务器关机，数据也依然存在，而不会丢失。但是数据的处理是在内存中的，处理前将数据从磁盘加载到内存，处理完毕之后将数据回写到磁盘。

InnoDB 将数据从磁盘每次最少读取一个页，每次写入磁盘也是最少一个页，一页默认情况下为 16KB。可以通过如下变量查看该设置:
```sql
$ show variables like 'innodb_page_size'; # Value 单位为字节
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| innodb_page_size | 16384 |
+------------------+-------+
```
> 注意： 这个参数在初始化数据目录之后，就不能再变更。


## InnoDB 的行格式 {id="row-format"}
我们往数据库中插入数据是以行为单位，比如500个用户就是500行数据。这些数据记录再磁盘上存放的格式称之为“行格式”。到目前为止，一共有4种格式:

| 格式名称       | 描述                                                          |  |
|------------|-------------------------------------------------------------|--|
| compact    | 下文详解                                                        |  |
| redundant  | 这是 MySQL5.0 以前使用的行格式，占用空间较多                                 |  |
| dynamic    | MySQL5.7 默认使用的格式，和 compact 类似，不同的是处理列溢出数据的策略，将所有溢出数据都存储在溢出页 |  |
| compressed | 和 dynamic 不同的是，会进行压缩                                        |  |

![Compact 行格式示意图](http://file-linker.oss-cn-hangzhou.aliyuncs.com/uA14dnoJXyRLhTaQ5wS6.png)

### 变长字段长度列表

变长字段长度列表是什么？比如我们有一行记录，三个变长（例如 varchar）字段分别为 A、B、C，对应的值为 `a`、`bbb`、`cccc`。那么变长字段列表记录的就是这三个字段实际值得长度，使用十六进制表示`04 03 01`, **按照字段的倒序排列。**

> 注意: 变长字段长度列表，只存储值非 NULL 字段。如果所有列都不是变长数据类型或者所有列的值都是 NULL 的话，就没有变长字段长度列表了。


### NULL 值列表

把 NULL 值字段单独处理，形成 NULL 值列表，以此来节省存储空间。如果所有字段都是 NOT NULL，就不会有这部分内容。**这里记录的顺序依然是倒序排列的**。

例如，有三个字段，分别是 A、B、C。这三个字段的值为 `a`, `NULL`, `NULL`。那么这个字段记录的就是`110`, 使用二进制 1 来表示空值，0 表示非空。因为不足一个字节，所以高位补零,最终的值为 `00000110`。

### 记录头信息

记录头信息由固定的5个字节组成，用于描述记录的一些属性。如下图所示：

![image.png](http://file-linker.oss-cn-hangzhou.aliyuncs.com/S4wwQDWweCrqyf2J79YW.png)

这些二进制位的含义如下表所示:

| 名称           | 长度 | 描述                                                                                                  |
|--------------|----|-----------------------------------------------------------------------------------------------------|
| 预留位1         | 1  | 没有使用                                                                                                |
| 预留位2         | 1  | 没有使用                                                                                                |
| deleted_flag | 1  | 标记该记录是否被删除                                                                                          |
| min_rec_flag | 1  | B+Tree 的每层非叶子节点中最小的目录项记录都会添加该标志                                                                     |
| n_owned      | 4  | 一个页面中的记录会被分成若干组，每个组中有一个记录是“带头大哥”，其余的记录是“小弟”。“带头大哥”记录的 n_owned 值代表该记录中所有的记录条数，而“小弟”记录的 n_owned 值都为 0 |
| heap_no      | 13 | 表示当前记录在页面堆中的相对位置                                                                                    |
| record_type  | 3  | 表示当前记录的类型：0 表示普通记录，1表示B+Tree非叶子节点的目录项记录，2表示 Infimum 记录，3表示 Supremum 记录                              |
| next_record  | 16 | 表示下一条记录的相对位置                                                                                        |

#### 记录的真实记录
记录的真实记录除了我们真实的字段值外，还有 3 个额外添加的列，如下表所示：

| 列名          | 是否必需 | 占用空间 | 描述           |
|-------------|------|------|--------------|
| DB_ROW_ID   | 否    | 6字节  | 行ID，唯一标识一条记录 |
| DB_TRX_ID   | 是    | 6字节  | 事务ID         |
| DB_ROLL_PTR | 是    | 7字节  | 回滚指针         |

> 注意: 这三个字段是排在我们自己定义的字段之前的。

InnoDB 表主键生成策略：优先使用用户自定义的主键，如果用户没有定义，则选取一个 NOT NULL 且 UNIQUE 的键为主键。如果也没有，则使用上表中的 DB_ROW_ID。