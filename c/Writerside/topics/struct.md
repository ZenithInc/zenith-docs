# 结构体

我们将整型、字符型、浮点型、指针......这些称之为是基础数据类型。然而，为了应对更复杂的应用程序，光这些基础的数据类型有些吃力，我们需要将这些数据类型聚合起来，形成新的、更高级的数据类型。所以，聚合数据类型，就是我们这一篇要讲述的，它们有结构体、联合体以及枚举。

### 结构体的定义和使用 {id="struct-defined-and-usages"}

当我们要在程序中描述更高级的概念的时候，使用基本类型是有些吃力的。比如说描述一个人，这个人的姓名是字符串类型的、这个人的年龄是整型的......所以我们有必要有一种更高级的类型来描述一个人。结构体应运而生，如果你有面向对象编程的经验，那么你也可以把结构体理解成简易的对象或者类。

结构体的语法定义如下:
```c
struct [结构体名] {
	<成员类型> <成员名>;
    ...
} [结构体变量];
```
需要注意的是，结构体的名字和结构体的变量是可以省略其中之一的。声明了结构体的名字就可以省略结构体变量的名字，声明了结构体变量的名字就可以省略结构体的名字。然后要重复使用结构体的时候，就可以定义结构体的名字，一次性使用就可以直接定义结构体的变量名。

就拿一个人类来举例，我们定义名为 `Person` 的结构体:
```c
struct Person {
 	char yypyypkk*name;
    int age;
};
typedef struct Person Bob;
struct Person Tom;
```
下面的代码展示了如何初始化一个结构体变量:
```c
struct Person bob = {"Bob", 13};		// 初始化全部的成员
struct Person tom = {"Tom"};	// 初始化部分的成员，其他未初始化的成员的默认值取决于编译器
struct Person John = {.age=13};	// 初始化指定的成员，这里的 '.' 是一个运算符，称为成员选择运算符
```
接下来，我们看看如何访问一个结构体的成员:
```c
tom.name = "Tom";
printf("Tom's age is %d\n", tom.age);
// 我们也可以把结构体赋值给一个指针
struct Person *tom_ptr = &tom;
printf("%d\n", tom_ptr->age);		// 如果是指针，就需要使用 ->, 而不是 . 
```
另外结构体是可以嵌套的，这样才能最大程度地发挥结构体的功效:
```c
typedef struct Company {
 	char *name;   
}
typedef struct Person {
    Company *company;		// Company 是另外一个结构体
}
// 访问如下
struct Company company = {.name="XXX"};
struct Person p = {.company=&company};
printf(p.company->name);
```

### 结构体的存储 {id="struct-memory-allocation"}

接着我们来看看结构体中的数据是如何存储的，首先来看 `&bob.name` 中存储的值是啥？是第一个内存地址 `0000000109d72f7e` 。这好理解，因为 `name` 这个成员是一个 `char *` 指针变量，存储的当然是地址啦:

![image.png](http://file-linker.oss-cn-hangzhou.aliyuncs.com/64lDN4KZ0CEI0jE5dRjr.png)

然后我们再来看看这个 `char *name`的指针指向的地址中存储的是什么值，是一个字符串，就是我们的 `Tom`:

![image.png](http://file-linker.oss-cn-hangzhou.aliyuncs.com/aELUpdNLuQwcGKvFhrMP.png)

那么这个结构体在内存中占据了多少的空间呢？我们可以使用 `sizeof` 运算符:
```c
printf("%ld\n", sizeof(struct Person));	// Output: 16
printf("%ld\n", sizeof(struct tom));	// Output: 16
printf("%ld\n", sizeof(char *));		// Output: 8
printf("%ld\n", sizeof(int));		// Output: 4
```
我们可以看到它占据了 16 个字节？它只有两个成员，第一个是 `char *` 指针类型确实是 8 个字节，第二个是 `int` ，32 bit 所以是 4 个字节也没有问题。那么不应该是 12 个字节吗？怎么会是 8 个字节呢？这是因为内存对其的缘故。那么什么是内存对其呢？下一章节继续。

### 内存对齐策略 {id="memory-align"}

上一节遗留了一个问题，我们说结构体是一种聚合类型，其是一些基本类型聚合在一起的。那么理论上说，它在内存中的大小应该是当中包含的基本类型的和。比如说当中包含了一个 `char` 类型的成员和一个 `int` 类型的成员，那么它的大小应该是 5 个字节，但实际上却不是。这是为什么呢？我们说这是因为编译器内存对其的缘故，那么什么是内存对齐呢？

我们来写一个 struct 来看一下:
```c
typedef struct Align {
    char a;
    short int c;
    char b;
    int d;
    long int e;
};
```
那么这个结构体在内存中占据了多少的空间呢？
```c
printf("%lu\n", sizeof(align));		// 24
// 一共有 5 个成员变量，按照道理他们的类型占据的空间应该是 16 字节，可上面输出确实 24 个字节
// char 1 Byte * 2 + short int 2 Byte + int 4 Byte + long int 8 Byte = 16 Byte
```
我们看到了吧，这个结构体比我们预想的空间占用多出了 8 个字节，这 8 个字节是哪里来的呢？我们来看一下它在内存中的存储数据:
```c
struct Align align = {'a', 1, 'b', 2, 1024};
printf("%lu\n", sizeof(align));		// 此处打断点，查看内存占用
```
然后来看看这个结构在内存中的存储情况:

![image.png](http://file-linker.oss-cn-hangzhou.aliyuncs.com/EOhSETg31exfHaNlXean.png)

我们来解读一下这张截图中的数据，也就是内存中的数据:

| 字节数            | 字节内容(从后往前读，十六进制)        | 真实的值(数字转十进制，字符不变） |
|----------------|-------------------------|-------------------|
| 1 到 2 个字节(2)   | 00 61                   | a                 |
| 3 到 4 个字节(2)   | 00 10                   | 1                 |
| 5 到 8 个字节(4)   | 00 00 00 62             | b                 |
| 9 到 16 个字节(8)  | 00 00 00 00 00 00 00 02 | 2                 |
| 17 到 24 个字节(8) | 00 00 00 00 00 00 04 00 | 1024              |

你看到嘛？比如说 `a` 是 `char` 类型的，按道理是一个字节，但是它会对齐到 2 个字节。与之一样的是 1 是 `short int` 类型的，也对齐到了 2 个字节。而 `b` 是 `char` 类型的，对其到 4 个字节。接着 2 是 `int` 类型的，按理是 4 个类型的，对其到了 8 个字节。而 `long int` 默认就是 8 个字节。

你发现了嘛？默认的策略是按照 2 的倍数对齐的。为什么对齐呢？有利于提升 CPU 读取数据的效率。我们把之前的定义的结构体的成员交换一下位置再来看看:
```c
typedef struct Align {
    char a;
    char b;
    short int c;
    int d;
    long int e;
};
```
我们交换了一下位置，把相同类型的成员放在一起，然后再来测试一下:
```c
struct Align align = {'a', 1, 'b', 2, 1024};
printf("%lu\n", sizeof(align));		// 16
```
只是交换了一下位置，就节省了 8 个字节，我们来看一下它的内存结构:

![image.png](http://file-linker.oss-cn-hangzhou.aliyuncs.com/CWjjluxMpcCRLYs8oBgB.png)

我们再以表格的形式解读这张截图:

| 字节数           | 字节内容(从后往前读，十六进制)        | 真实的值(数字转十进制，字符不变） |
|---------------|-------------------------|-------------------|
| 1 字节(1)       | 61                      | a                 |
| 2 字节(1)       | 01                      | 1                 |
| 3 到 4 字节(2)   | 00 62                   | b                 |
| 5 到 8 个字节(4)  | 00 00 00 02             | 2                 |
| 9 到 16 个字节(8) | 00 00 00 00 00 00 04 00 | 1024              |


对比一下两张表格，你就看到了我们优化结构体的在内存中的存储空间的过程。

### 枚举类型 {id="enumerated-type"}

枚举类型的定义和结构体或者联合体都相似，比如我们以文件类型为例, 定义了 `png、jpeg、bmp、unknown` 三种图片类型以及一个未知:
```c
typedef enum FileFormat {
    PNG, JPEG, BMP, UNKNOWN
} FileFormat;
```
然后我们来写一个程序判断图片文件的类型:
```c
FileFormat GuessFormat(char *file_path) {
    FILE *file = fopen(file_path, "rb");
    enum FileFormat file_format = UNKNOWN;		// 默认为未知
    if (file) {
        char buffer[8] = {0};
        size_t bytes_count = fread(buffer, 1, 8, file);	// 读取指定文件从第 1 到第 8 个字节
        if (bytes_count == 8) {
            // 根据前 8 个字节来判断文件的类型
            if (*((short *) buffer) == 0x4d42) {
                file_format = BMP;
            } else if (*((long long *) buffer) == 0x0a1a0a0d474e5089) {
                file_format = PNG;
            } else if (*((int *) buffer) == 0xe0ffd8ff) {
                file_format = JPEG;
            }
        }
        fclose(file);
    }
    return file_format;
}
```
我们知道文件实际上就是一些二进制的组合编码，就拿图片文件来说，一般会在字节序(编码)的开头以特定的字节来表明自己的文件类型，所以通过读取文件的前 8 个字节我们就可以判断文件的类型。不同文件类型对应的字节序如下表所示，这也解释了代码第 8 行、第 9 行以及第 12 行中出现的哪些十六进制数是什么意思:

| 文件类型 | 十六进制数(小端序)              |
|------|-------------------------|
| BMP  | 42 4D                   |
| PNG  | 89 50 4E 47 0D 0A 1A 0A |
| JPEG | FF D8 FF E0             |

> 注意: 并不是所有的对应的类型的图片文件都是这样的，只是大部分都是这样的。

## 共用体 {id="union"}

在C语言中，共用体（union）是一种特殊的数据结构，它允许你在相同的内存位置存储不同类型的数据。这意味着一个共用体可以有多个成员，但是在任何时候
只能有一个成员含有值。共用体的大小至少等于其最大成员的大小。

共用体的主要用途包括：

1. **内存节省**：由于共用体的成员共享相同的内存区域，因此它可以用来节省内存。这在处理大量此类结构时尤其有用。

2. **不同的视角访问数据**：共用体允许以不同的类型来访问同一块内存，这对于低级编程来说非常有用。例如，在硬件编程或网络通信中，你可能需要将相同
的数据位以不同的格式（如整数、浮点数、字节数组等）来访问和解释。

3. **类型转换**：共用体可以用于实现显式的类型转换，尤其是在不同的数据类型具有相同的内存表示时。

举个例子，下面是一个共用体的定义：

```c
union Data {
   int i;
   float f;
   char str[20];
};
```

在这个例子中，`Data` 可以存储一个整数、一个浮点数或一个字符数组，但在同一时间只能存储其中之一。如果你写入 `i`，然后读取 `f`，得到的将是 `i` 
的内存表示形式作为浮点数的解释。

共用体的这种特性在需要紧凑存储或与特定硬件接口交互的低级编程中非常有用。然而，使用共用体也需要谨慎，因为不恰当的使用可能会导致数据解释错误或不一致。

## 总结 {id="summary"}

本文提供了一个详细的概述和解释关于C语言中的高级数据结构，特别是结构体、共用体和枚举类型。

1. **结构体**: 首先介绍了结构体，这是一种用于聚合不同数据类型的高级数据类型。结构体的定义和用法通过例子展示，如定义一个人的姓名和年龄。
解释了结构体的初始化、成员访问方式以及结构体的嵌套使用。还提到了结构体可以用来描述更复杂的数据结构，如公司和员工的关系。

2. **结构体的存储**: 接下来，文档讨论了结构体在内存中的存储方式，解释了成员变量如何在内存中排列，以及`sizeof`运算符的使用。文档特别强调了
内存对齐的概念，说明了结构体成员如何因内存对齐而占用额外的空间，并通过实例演示了内存对齐的效果。

3. **内存对齐策略**: 解释了内存对齐的原因和策略，指出结构体的实际大小可能因内存对齐而大于成员类型大小的总和。通过更改结构体成员的顺序，
展示了如何优化结构体的内存使用。

4. **枚举类型**: 还介绍了枚举类型，这是一种用于定义命名整数常量的数据类型。通过文件格式的例子，展示了如何定义和使用枚举类型来处理特定问题。

5. **共用体**: 最后，介绍了共用体的概念，这是一种允许在同一内存位置存储不同类型数据的结构。文档讲述了共用体的用途，如内存节省、不同视角访问数
据和类型转换，并通过一个包含整数、浮点数和字符数组的共用体例子来演示其用法。

本文介绍了关于C语言中结构体、枚举类型和共用体的一个全面且深入的解释，可以帮助你理解这些高级数据结构的定义、使用和存储方式。