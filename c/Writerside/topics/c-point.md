# C 指针 

指针是在 C 语言中的概念非常简单，是一种变量，特殊之处在于其它存储的数据是内存地址。正是因此所以它才强大，给予了程序员直接读写内存地址、提升性能的能力。也正是因此，它才可怕，因为稍不注意就可能出现地址越界、内存逃逸能严重的问题。这一篇文档将详细描述指针以及其在 C 语言中的应用。

## 指针的定义和基本使用 {id="basic-syntax"}

我们说指针也是一种变量，比较特别的是其指向的是内存地址，而其他变量则是指向具体的内存中的值。那么我们如何在 C 语言中定义指针呢？在变量名的前面加上一个 `*` 就可以了。
```c
int *num;
double *memory = NULL;
printf("%p %p\n", num, memory);   // Output: 0x7ffeeb798ad8 0x0(NULL 的内存地址)
```
所以，也经常听到变量是值的内存地址，而指针是指向变量的变量。所以，我们可以使用 `&` 取地址符将变量的内存地址赋值给指针:
```c
int num = 23;
int *num_pointer = &num;		// 将变量的内存地址赋予给指针
printf("%d\n", *num_pointer);   // Output: 23
num = 24;
printf("%d\n", *num_pointer);   // Output: 24
*num_pointer = 25;			// *num_pointer 中的 * 是解引符号，*num_pointer 修改的是值
printf("%d\n", num);        // Output: 25
```
那么指针占用了多大的内存空间呢？我们可以使用 `sizeof` 运算符来打印它:
```c
printf("%ld\n", sizeof(int *));         // Output: 8
printf("%ld\n", sizeof(double *));      // Output: 8
printf("%ld\n", sizeof(char *));        // Output: 8
```
也就是说，不管是什么类型的指针。在 64bit 的操作系统中都是占据了 8 个字节的内存空间的，如果是 32bit 那么就应该是 4 个字节吧。

指针是指向变量的，这个变量自然是包括普通变量和指针变量啦，所以我们可以定义一个指向指针的指针:
```c
int a = 24;
int *b = &a;
int **c = &b;
// Output: a 0x7ffee2766ab8	b 0x7ffee2766ab8	 c 0x7ffee2766ab8
printf("a %p\tb %p\t c %p\t", &a, b, *c);
```
上面定义了三个变量，第一个是普通变量，它的值是 24。第二个变量是一个指向变量 `a` 的指针变量，它存储的是 `a` 变量的内存地址。第三个变量也没有什么不同的，是指向变量 `b` 的内存地址。所以当我们使用 `*c` 解引用之后就是变量 `a` 的内存地址。

## 只读指针变量和只读变量指针 {id="readonly-pointer"}

之前的文档中已经说了什么是只读变量，如下所示:
```c
const int number = 10;
int const number2 = 20;
```
这是同一种写法，建议采用第一种写法。因为从前往后读更容易理解, `const` 这个修饰词是修饰 `int` 的值的。这种情况下，被声明的变量是不允许更改的。

然后我们再来看看只读的指针，如下所示:
```c
int num = 10;
int const *num_pointer = &num;
num = 20;
printf("num:%d\n", *num_pointer);   // Output: num:20
```
这里， `const` 是修饰 `*num_pointer` 这个指针的，所以，指针不能修改的，而 `num` 是可以修改的。然后我们在来看看只读变量和只读指针的混合写法:
```c
const int num = 20;
const int *const num_pointer = &num;
num = 30;           // 不能修改
num_pointer = NULL; // 不能修改
```
这种情况下， `num` 和 `num_pointer` 都不能够修改。

## 空指针和野指针 {id="nul-pointer-and-wild-pointer"}

在 C 语言的指针的使用过程中，有两种指针需要格外注意，分别是空指针和野指针。首先来演示什么是空指针:
```c
int *p = NULL;
*p = 3;			// 错误
```
当一个指针的值指向 `NULL` 的时候，其就是一个空指针。对空指针的任何赋值都会产生一个错误, 哪怕你赋值的就是 `NULL` 。但是如果指针不再使用，那么就可以赋值为 `NULL` ，以释放指针所指向的内存区域。

野指针，也称之为是迷途指针、悬空指针，说的是指向非法的、不可控的内存空间的指针。比如下面这个示例:
```c
// 定义了一个全局的指针变量为 p
int *p;
void test(void) {
    int a = 1;
    // 将局部变量 a 的地址赋予全局变量 p
    p = &a;
}
int main() {
    test();
   	// 打印的 p 的指针地址是不可控的，不可知的，因为 a 变量的地址已经被无效的了
    printf("%p\n", p);
    return 0;
}
```
当指针引用了一个无效的地址的时候，就成了野指针，就会导致错误出现，所以要特别小心。

## 指针的运算 {id="pointer-calc"}

因为指针指向的是内存地址，而内存的地址实际上就是一个整数，所以指针也是可以进行加减运算的。我们先来看看加法运算:
```c
int a = 1;
int *p = &a;
// Output: 0x7ffee2fc4ab8 0x7ffee2fc4abc 4
printf("%p %p %ld\n", &a, (p + 1), sizeof(int));
```
定义了一个整型类型的指针，对其加 1，实际上就是加上整型的字节数( `sizeof(int)` ),也就是 4 个字节，减法亦是如此，可以自己试试看。 `0x7ffee2fc4abc - 0x7ffee2fc4ab8 = 4` 。

在理解了指针的加减运算之后，我们来透过指针理解数组的本质。当我们去使用 `array[index]` 这样的语法的时候，本质上就是在做指针的加减运算。之前我们也说过 `array` 的变量名实际上是数组第一个元素的内存地址，那么索引就是相对于第一个元素的地址的偏移量。所以，我们可以通过对指针的运算来获取对应的元素:
```c
int numbers[] = {1, 2, 3, 4, 5};
printf("%d\n", *(numbers + 3));		// Output: 4
```
对于数组而言，元素的地址是连续的、递增的，所以也是可以进行对比的:
```c
int numbers[] = {1, 2, 3, 4, 5};
printf("%d\n", numbers > numbers + 3);		// Output: 0
printf("%d\n", numbers + 1 < numbers + 3);	// Output: 1
```
> 注意: 不同的两个数组之间的对比是没有意义的，必须要是同一个数组中连续的值地址才能进行对比。


## 左值和右值 {id="left-value-and-right-value"}

在 C/C++ 中，左值和右值是一个令人迷惑的概念，两种语言还有所区别。我们来说说在 C 语言中相关概念， **左值指的是可以被操作的内存空间，而右值指的是用于操作左值的值** 。

我一直很迷惑的是，为什么就出现这两个令人迷惑的概念。思来想去，这是为了让我们理解清楚，什么样的值可以出现在赋值运算符的左边？什么样的值可以出现在赋值运算符的右边？换句话说，能够出现在左边的值称之为左值，能够出现在右边的值称之为右值。

我们来运行一些示例来回答这两个问题。首先，什么样的值可以称之为左值：
```c
int i;
i = 10;		// 可以，因为 i 是一个可以被操作的地址
int *p = &i;
*p = 20;	// 可以，因为 *p 也是一个可以被操作的地址
int numbers[] = {1, 2}; 
numbers[1] = 0;		// 可以，因为 numbers[1] 是一个可以被操作的地址
```
那么什么样的值不能被用作左值呢？如下示例:
```c
int i;
10 = i;	// 不可以，10 是字面量，指向一个常量的地址，是不能被修改的
int *p = &i;
*p + 1 = 10;	// 不可以,因为 *p + 1 之后，也是一个地址的常量
*p++ = 10;		// 这是可以的，因为 ++ 的运算等级更高，就如下这种形式: *(p++) = 10;
```
看过这些示例，你明白左值和右值了吗？然后我们再来弄清楚一个非常重要的概念，叫做 **左值转换**。我们来看下面这两个表达式语句(表达式语句由表达式和末尾的分号 `;` 组成):
```c
// 这条语句中， num 变量是作为左值的存在，赋值运算符的左边必须是左值，能够指向一个地址
num = 1;		
// 但是，这条语句中的 num 变量就不能说成是一个左值，因为左值是一个地址，不能那地址去和数值比较
num <= 1;	
```
所以，在第四行的 `num <= 1` 中，就发生了左值转换，即将左值隐式转换成左值的指向的地址中所存储的值，所以值是可以和数字 `1` 进行比较的。

所以，我们说**赋值运算符 `=` 是不会发生、也不能发生左值转换的**，不然就成了将一个值赋值给一个值了，所以赋值运算符的左边必须是一个左值，即一个内存地址。所以，**我们说类似于 `<=` 这样的运算符的是会发生左值转换的**，因为我们不能那一个地址和数值进行比较，必须将左值转换成具体的数值才可以。

> 在 C 语言中，运算符的作用是对操作数进行计算和加工。


## 使用指针作为传参和返回值 {id="using-pointers-as-functions-parameters-and-return-values"}

在 C 语言中，经常会将指针作为传参和返回值。我们先来说说作为传参的情况，看下面的示例:


## 参考资料 {id="reference"}

1. 《C语言非常道》李忠