# 数组 

在 C 语言中，数组也是一种主要的数据类型，是很多数据结构的基础。什么是数组呢？就是一组数据，使用索引来访问数据。这一篇文档中，我们详细来说一下数组在 C 语言中的原理和应用。

## 数组的定义 {id="defined-array"}

在 C 语言中，一个数组中的元素必须都是相同类型的。所以，定义一个数组需要声明其类型以及元素数量。可以初始化值，也可以不初始化值。如下示例, 我们一年有 12 个月份:
```c
int months[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
// 或者指定数量
int months[12] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
```
如何遍历当中的元素呢？
```c
for (int i = 0; i < 12; i++) {
	printf("Element %d : %d\n", i, months[i]);
    // Element 0 : 1
	// Element 1 : 2
	// Element 2 : 3		省略其他
}
```
数组的索引是从 0 开始的，不是从 1 开始的，这点要记住。访问是通过数组的名字加上索引的方式，比如 `months[1]` 访问的是数组的第二个元素。索引和值的对应关系如下表所示:

| index  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9  | 10 | 11 |
|--------|---|---|---|---|---|---|---|---|---|----|----|----|
| months | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |

那么如果数组的元素没有初始化呢？值是多少呢？如果你定义的是整型，那么初始值都是 0。同理，如果你定义的是 `float` 类型，那么输出的是就会是 `0.000000` 。
```c
int months[];
int months[12] = {1, 2, 3, 4, 5 ,6};		// 也可以初始化部分元素，那么未初始化的值是 0
// 从 C99 开始，也支持给部分的元素赋予初值
int months[12] = {[2] = 3, [3] = 4};
int months[12] = {[2] = 3, 4, 5, 6};	// 从第二个元素开始赋值
```
> 注意: 对于 auto 变量而言，因为变量是存储在函数栈中的。未初始化的值，默认值是依赖于编译器的。也就是说，不同的编译器对此的处理方式是不一样的。有的编译器会全部设置为类型的默认值，有的编译器则会取决于之前的函数调用栈的情况。所以，最好是给这些数组都初始化值。


## 数组的边界 {id="array_range"}

什么是数组的边界呢？以上文中定义的 `months` 数组为例，其边界就是数组索引的边界，就是从 0 到 11。如果超出了这个范围就会产生 **数组索引越界** ，这是一个危险的操作，比如 `months[12]` 就会发生数组索引越界。
```c
int months[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
printf(months[12]);	// 索引越界
```
在 C 语言中，并不会检测你的索引是否越界。也就是说，从代码上而言，上面的代码是不会有任何错误的。而 `months[12]` 会取到什么值呢？这是不确定的，取决于越界的索引指向的内存地址中实际的值，如下图所示:

<img src="http://file-linker.oss-cn-hangzhou.aliyuncs.com/q5LHaARo1CeOiLK68Q1I.png" alt="array round"/>

这个值会是 `b8fac7e0`, 那么这个值是哪里来的？谁也说不清楚，可能是之前的函数调用后留下的值。**所以数组越界导致的后果是严重的、取到的值是不可预测的。在程序中，我们应该避免这样的情况的发生。**

所以数组的原理也很简单，以 `months`数组为例， `months`这个变量就是数组的起始地址，而索引就是起始地址的偏移值，起始地址加上偏移值就是具体索引指向的值。

那么 C 语言为什么不去像现在很多的高级语言一样去检查数组的边界呢？**检查数组的越界是有性能上的损耗的，而 C 语言最大的特点就是高性能，所以也作为操作系统、嵌入式等领域语言的首选。所以，它选择相信开发者自己回去检查数组的边界，保证数组不越界。**

从 C99 开始，C 语言支持了变长的数组，如下示例:
```c
int size = 12;
int arr[size];
arr[12] = 12;
printf("%d\n", arr[12]);	// Output: 12
```

## 字符串也是数组 {id="string-is-array"}

在 C 语言中，字符串本质上也是一个 `char` 的数组。比如说，我们定义一个 `Hello World` 的字符串,遍历它:
```c
char str[11] = "Hello World";
for (int i = 0; i < 11; i++) {
	printf("%c", str[i]);       // Output: Hello World
}
```
如果出现了乱码, 那是因为在 C 语言中，字符串以 `\0` 结尾，所以 `Hello World` 这个字符实际上是占据了 12 个字节，所以应该声明为 `char str[12]`。

## 二维数组 {id="two-dimensional-array"}

上文中我们说的都是一维的数组，那么什么是二维数组呢？就是数组中存储的还是数组。二维数组的定义如下:
```c
int numbers[2][10] = {
	[0] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
	[1] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
};
```
然后我们来写一个函数对这个数组中的每一个元素进行求值:
```c
void sum(int row, int column, int numbers[][column]) {
    for (int i = 0; i < row; i++) {
        int sum = 0;
        for (int j = 0; j < column; j++) {
            sum += numbers[i][j];
        }
        printf("Result i:%d\n", sum);
    }
}
```
需要注意的是，在 C 语言中，每一个数组并不包含自己元素的大小，所以也不会去检查数组索引的越界。当将数组作为参数在函数中传递的时候，需要将数组的大小一起传递，比如 `sum(int row, int column, int numbers[][column])` 这样的写法。

## 案例一: 打乱数组 {id="shuffle-array"}

打乱数组需要一定次数的去交换数组指定的两个值，所以我们需要先创建一个函数去交换数组两个元素的值:
```c
void Swap(int arr[], int left, int right) {
    int temp = arr[left];
    arr[left] = arr[right];
    arr[right] = temp;
}
```
然后，我们遍历数组，将每一个遍历到的元素和随机的索引指向的值进行交换即可:
```c
void ShuffleArray(int arr[], int length) {
    srand(time(NULL));
    for (int i = length - 1; i > 0; --i) {
        Swap(arr, i, rand() % i);
    }
}
```
最后，我们来测试这个交换数组的函数:
```c
int main() {
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    ShuffleArray(arr, 10);
    for (int i = 0; i < 10; i++) {
        // 因为是随机的，所以生成的数的顺序肯定是和我的不一样的
        // Output: 2	3	0	9	1	7	6	4	8	5
        printf("%d\t", arr[i]);
    }
    return 0;
}
```