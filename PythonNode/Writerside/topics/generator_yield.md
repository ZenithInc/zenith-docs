# 生成器和迭代器

这一篇文档将会描述什么是生成器、什么是迭代器。

### 迭代器协议

所谓的协议，其实有点像面向对象中的接口，是一种约定。而迭代器协议，也是一种约定。看如下这段代码:

```python
with open('/etc/passwd') as file:
    for line in file:
        print(line)
```

它将文件 `/etc/passwd` 中的每一行文本都打印了出来，为什么我们可以使用 `for` 去遍历这个对象呢？因为这个对象实现了 **迭代器协议** 。我们说协议是一种约定，那么迭代器协议约定了什么呢？约定了对象中需要实现一个 `__iter__` 方法。我们来看一下 `open` 对象是否如此:

```python
dir(open('/etc/passwd')) ## 输出内容如下
## [......省略......, '__iter__',......省略......]
```

我们自己的对象中也可以通过实现 `__iter__` 方法，提供每一次遍历的下一个值，进而使其拥有可遍历的能力。

### 生成器

通常情况下，我们的函数在内存中的生命周期是从执行这个函数开始，直到这个执行结束或者使用了 `return` 为止。一个函数通常只能 `return` 一次。

而生成器则是使用 `yield` 关键字代替了 `return` , 让我们的函数有了多次返回值的能力。为什么要多次返回呢？一次性返回不是更好吗？

是的，如果返回的内容很少量的话，这样做是没有问题的，比如我要查询 100 个用户。但是如果查询的是大量的数据，比如我要查询 100000 个用户，一次性返回会让内存吃紧。所以，我们使用 `yield` , 也就是生成器，让函数可以分批次多次返回，以时间换取空间。

```python
def get_list():
    yield 1
    yield 2
    yield 3

for li in get_list():
    print(li)
```

在上面这个例子中，只是简单的模拟了几个数字来证明使用 `yield` 关键字可以让函数具备多次返回的能力。但这个例子本身并没有任意意义，在实际的生产中，我们可能是使用 `get_list` 这个函数去获取数据库中的数据、可能是使用它去获取几个 GB 的日志文件，每次读取一行数据，可能是去获取一些无穷无尽的网络资源。