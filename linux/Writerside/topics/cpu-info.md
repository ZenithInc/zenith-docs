# 查看 CPU 信息 

这篇文档介绍了如何查看 CPU 信息。

<include from="file-system.md" element-id="proc" />

## 查看 CPU 信息 {id="cat-cpu-info"}

我们可以使用 `cat /proc/cpuinfo` 这条命令来查看 CPU 信息：

<img src="http://file-linker.oss-cn-hangzhou.aliyuncs.com/mtRmbBN3tWKQw9p1P3Rr.png" alt="/proc/cpuinfo"/>

## 查看系统平均负载 {id="what-is-system-avg-load"}

如果我们的主机是单核 CPU，那么其满载就算是单位 1。小于这个值，就表明并没有超出其负载能力，而大于该值，就表明超出了其承载能力。按照经验来说，单
核 CPU 的负载在 0.7 以下表明负载是安全的。否则就需要优化了。

如果是多核 CPU 呢？单核的负载能力是 1，那么多核的负载能力就是 N(CPU 核心数)。如果平均负载小于 N，则表示负载是正常的。

我们可以使用`cat /proc/loadavg` 这条命令来查看 CPU 的负载情况，如下所示:
```Shell
$ cat /proc/loadavg
0.00 0.00 0.00 2/173 7395
```
前面三个数字表示 CPU 最近 1分钟、5分钟、10分钟的平均负载, 那么什么是平均负载呢？**平均负载是指单位时间内，系统处于可运行状态和不可中断状态的
平均进程数**，它和 CPU 使用率并没有直接关系。

那么什么是可运行状态的进程？什么是不可中断状态的进程呢？

**可运行状态的进程指的是正在使用 CPU 或者正在等待 CPU 的进程，也就是我们用 `ps` 命令看到，处在 R 状态(Running 或者 Runnable) 的进程。**

**不可中断状态的进程指的是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应。也就是使用 `ps` 命令
看到处于 D 状态(Uninterruptible Sleep, 或者 DISK Sleep) 的进程**。这时候，如果被中断，就可能会出现磁盘数据和进程数据不一致的情况。

所以，**不可中断状态实际上是系统对进程和硬件设备的一种保护机制。**

所以，平均负载的含义，如下表所示:

| 平均负载 | CPU数量 | 含义                 |
|------|-------|--------------------|
| 2    | 2     | CPU 两个核心全部被占用      |
| 2    | 4     | CPU 一半的核心被占用       |
| 2    | 1     | CPU 有一半的进程争抢不到 CPU |

所以，最理想的情况是平均负载等于 CPU 数量，如果大于 CPU 数量则表示过载。这个数字如果大于 70% 则表示可能会过载。

另外，对于 CPU 密集程序来说，平均负载是和 CPU 使用率是一致的。但是对于 I/O 密集的程序来说，平均负载高并不一定是 CPU 使用率高，因为程序可能在
 I/O 等待，CPU 并不一定忙碌。

## 使用 uptime 命令查看负载 {id="uptime"}

uptime 命令有两大功能，一个是查看机器开机的时长，另一个是查看 CPU 负载情况：
```Shell
$ uptime
22:44:08 up 15 days,  1:08,  1 user,  load average: 0.00, 0.00, 0.00
```
解释一下输出的信息，如下表:

| 输出信息                           | 描述                         |
|--------------------------------|----------------------------|
| 22:44:08                       | 系统当前时间                     |
| up 15 days                     | 主机运行时间                     |
| 1 user                         | 用户总的连接数                    |
| load average: 0.00, 0.00, 0.00 | 系统平均负载,统计最近 1、5、15 分钟的平均负载 |

## 使用 top 查看 cpu 负载情况

我们可以使用`top`命令来查看资源的一些实时信息，如下图所示:

<img src="http://file-linker.oss-cn-hangzhou.aliyuncs.com/gbbdbu7LM6nu8nqyJz1D.png" alt="top"/>

第一行的输出介绍:

| top | 当前系统时间 | up | 运行了 15 天 1 小时 9 分钟 | 一个登录用户 | 系统负载，参考上文 |
|-----|--------|----|--------------------|--------|-----------|

第二行的输出介绍:

| Tasks | 系统上共有101个进程 | 1 个进程正在运行 | 100 个进程在休眠 | 0 个进程被停止 | 0个僵尸进程 |
|-------|-------------|-----------|------------|----------|--------|

第三行的输出信息介绍:

| `0.3 us`  | 用户空间占用了0.3%的 CPU 时间          |
|-----------|------------------------------|
| `0.3 sy`  | 系统空间占用了0.3%的 CPU 时间          |
| `0.0 ni`  | 改变过优先级的进程占用了0%的 CPU 时间       |
| `99.0 id` | CPU有99%的时间处于空闲               |
| `0.2 hi`  | 硬件中断占用了0.2%的 CPU 时间          |
| `0.2 si`  | 软件中断占用了0.2%的 CPU 时间          |
| `0.0 st`  | 被偷走的时间（在虚拟化环境中用于其他的虚拟CPU）为0% |

第四行的输出信息介绍:

| 共1829.3 MB 内存 | 103.7MB空闲 | 636.5MB使用 | 1089.1MB缓冲缓存 | 1009.5 可用，考虑了缓冲缓存 |
|---------------|-----------|-----------|--------------|-------------------|

最后是进程默认展示的这些列的信息:

| PID     | 进程ID               |
|---------|--------------------|
| USER    | 运行进程的用户            |
| PR      | 进程优先级              |
| NI      | 进程的nice值，影响进程的优先级  |
| VIRT    | 虚拟内存的使用量           |
| RES     | 物理内存的使用量（常驻内存）     |
| SHR     | 共享内存的大小            |
| S       | 进程状态（S休眠，R运行，Z僵尸等） |
| %CPU    | 该进程占用的CPU百分比       |
| %MEM    | 该进程占用的物理内存百分比      |
| TIME+   | 该进程占用的CPU时间总量      |
| COMMAND | 进程启动的命令名称          |

## 使用 iostate 查看 CPU 信息 {id="iostate"}

`iostat` 命令能够查看 CPU 的详细信息，使用 `iostate -c 1 3`。`-c`选项表示只显示 CPU 的使用状态，`1 3` 表示采样的周期为 1 秒，采样的频率
为 3 次，命令输出如下所示:
```Shell
$ iostat
              disk0       cpu    load average
    KB/t  tps  MB/s  us sy id   1m   5m   15m
   41.01    4  0.18   3  1 96  1.85 1.68 1.72
```

截图中输出项的各字段的含义如下表所示:

| 字段      | 描述                                                |
|---------|---------------------------------------------------|
| %user   | 显示了 CPU 在用户级(应用程序)执行时产生的时间百分比                     |
| %nice   | 显示了 CPU 在应用程序使用 NICE 权限执行时产生的百分比[1]               |
| %system | 显示了 CPU 在系统级(内核)执行时产生的时间百分比                       |
| %iowait | 显示了 CPU 空闲且系统有未完成的磁盘 I/O 请求的时间百分比                 |
| %steal  | 显示了 hypervisor 服务另一个虚拟处理器时，虚拟 CPU 等待实际 CPU 的时间百分比 |
| %idle   | 显示了 CPU 空闲且系统没有未完成的磁盘 I/O 请求的时间百分比                |

<note>
NICE 表示进程可被执行的优先级的修正数值。它影响进程的优先级：PRI(new) = PRI(old) + nice。这样，当 nice 值为负值时，该程序优先级值降变小，优先级会变高从而得以执行。
</note>

实际运维过程中一些经验的总结如下:

- `%iowait` 的值过高，表示硬盘存在 I/O 瓶颈
- `%idle` 值过高，表示 CPU 比较空闲
- `%idle` 值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应该加大内存容量
- `%idle` 小于 70，I/O 压力就叫大了，一般读取速度有较多的 wait
- `%idle` 值如果持续低于 10，那么系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU

## 总结 {id="summary"}

本文详细介绍了在Linux系统中查看CPU信息的几种方法。首先，通过`cat /proc/cpuinfo`命令可以获取到CPU的具体硬件信息，包括型号、核心数等；而
`cat /proc/loadavg`命令则用于查看系统的平均负载，它展示了最近1分钟、5分钟和15分钟内系统的平均进程数，并对平均负载的概念进行了深入解释，指出
它不仅与CPU使用率有关，还反映了进程在运行或等待CPU以及处于不可中断状态的数量。

接着，文章介绍了`uptime`命令，该命令不仅可以显示系统的运行时间，还能展示1分钟、5分钟和15分钟的平均负载情况。另外，`top`命令提供了更详细的实时
资源信息，如CPU、内存使用状况及各个进程的状态和资源占用详情。

最后，文档介绍了`iostat`命令，它可以用来监控CPU的使用状态，特别是 `%user`、`%nice`、`%system`、`%iowait`、`%steal`和`%idle`等各项指
标的意义，帮助用户识别CPU是否存在瓶颈、I/O是否存在问题以及其他性能相关的问题。同时，文中还给出了实际运维过程中的经验总结，为用户分析系统性能提
供参考依据。